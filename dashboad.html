<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brand Tone Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font for a clean look */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        /* Custom scrollbar for output area */
        #output-area::-webkit-scrollbar {
            width: 8px;
        }
        #output-area::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 4px;
        }
    </style>
</head>
<body class="p-4 sm:p-8 flex justify-center items-center min-h-screen">
    <div class="w-full max-w-3xl bg-white shadow-2xl rounded-xl p-6 md:p-10 border border-gray-100">
        <h1 class="text-3xl font-bold text-gray-800 mb-2">Brand Tone Analyzer</h1>
        <p class="text-gray-500 mb-6">Select your target tone and paste your content below. The Gemini model will analyze the match.</p>

        <div class="mb-6">
            <label for="tone-input" class="block text-sm font-medium text-gray-700 mb-2">Target Brand Tone</label>
            <select id="tone-input" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 ease-in-out">
                <option value="Professional and Formal">Professional and Formal</option>
                <option value="Casual and Friendly" selected>Casual and Friendly</option>
                <option value="Urgent and Authoritative">Urgent and Authoritative</option>
                <option value="Empathetic and Supportive">Empathetic and Supportive</option>
                <option value="Witty and Playful">Witty and Playful</option>
                <option value="Academic and Informative">Academic and Informative</option>
            </select>
        </div>

        <div class="mb-6">
            <label for="prompt-input" class="block text-sm font-medium text-gray-700 mb-2">Text to Analyze</label>
            <textarea id="prompt-input" rows="4" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 ease-in-out" placeholder="Paste the text you want to check here.">We are extremely delighted to inform you that our flagship product, the revolutionary Chronos X-2000, is now available for immediate delivery. Get yours today!</textarea>
        </div>

        <button id="call-api-button" 
                class="w-full px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50 transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
            Analyze Tone
        </button>

        <div class="mt-8">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">Analysis Result</h2>
            <div id="output-area" class="min-h-[150px] max-h-[300px] overflow-y-auto bg-gray-50 border border-gray-200 rounded-lg p-4 whitespace-pre-wrap text-gray-700 text-sm transition-all duration-300">
                <p id="status-message" class="text-gray-400 italic">Enter text and click 'Analyze Tone' to begin...</p>
                <div id="generated-text" class="mt-2 font-medium"></div>
            </div>
            
        </div>
    </div>

    <script>
        const API_MODEL = 'gemini-2.5-flash-preview-09-2025';
        const apiKey = "AIzaSyA7tIxt23Z3JySWdiLhz1IGpTE4rTBm0yE"; // API Key is provided by the environment

        const button = document.getElementById('call-api-button');
        const textInput = document.getElementById('prompt-input'); 
        const toneInput = document.getElementById('tone-input'); 
        const emailInput = document.getElementById('email-input');     // NEW
        const reviewInput = document.getElementById('review-input');   // NEW
        const statusMessage = document.getElementById('status-message');
        const generatedText = document.getElementById('generated-text');

        button.addEventListener('click', () => {
            const textToAnalyze = textInput.value;
            const targetTone = toneInput.value;
            const userEmail = emailInput.value;     // Get email value
            const userReview = reviewInput.value;   // Get review value
            
            if (!textToAnalyze.trim() || !targetTone.trim()) {
                statusMessage.textContent = 'Error: Please enter the Text to Analyze.';
                generatedText.innerHTML = '<span class="text-red-600">The Text to Analyze cannot be empty.</span>';
                return;
            }

            generatedText.innerHTML = '';
            statusMessage.textContent = 'Calling API...';
            button.disabled = true;

            // The core logic calls the unified API function
            callGeminiAPI(textToAnalyze, targetTone)
                .then(result => {
                    if (result.error) {
                        statusMessage.textContent = 'Error: API call failed.';
                        generatedText.innerHTML = `<span class="text-red-600 font-normal">${result.error}</span>`;
                    } else {
                        statusMessage.textContent = 'Analysis complete:';
                        
                        // Display the analysis result
                        generatedText.innerHTML = formatToneAnalysis(result.text, result.sources); 

                        // NEW STEP: Send collected data (email/review) to a backend service
                        // The raw model text is sent for context.
                        submitFeedback(userEmail, userReview, result.text);
                    }
                })
                .catch(err => {
                    statusMessage.textContent = 'Fatal Error during API communication.';
                    generatedText.innerHTML = `<span class="text-red-600 font-normal">Check console for details: ${err.message}</span>`;
                    console.error("API Call Error:", err);
                })
                .finally(() => {
                    button.disabled = false;
                });
        });


        /**
         * NEW: Handles sending optional user data to a hypothetical backend endpoint.
         * NOTE: Requires a live, secure backend to function.
         * @param {string} email The user's email address.
         * @param {string} review The user's review/comment.
         * @param {string} analysisResult The full text of the analysis for context.
         */
        async function submitFeedback(email, review, analysisResult) {
            const trimmedEmail = email.trim();
            const trimmedReview = review.trim();

            if (!trimmedEmail && !trimmedReview) {
                console.log("No email or review provided. Skipping submission.");
                return;
            }

            const data = {
                email: trimmedEmail,
                review: trimmedReview,
                analysis: analysisResult 
            };

            // !!! IMPORTANT: Replace this with your actual secure backend URL !!!
            const backendUrl = 'https://your-secure-server.com/api/submit-feedback'; 
            
            try {
                const response = await fetch(backendUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });

                if (response.ok) {
                    console.log('Feedback successfully simulated/submitted.');
                    // Optionally clear fields after successful submission
                    emailInput.value = '';
                    reviewInput.value = '';
                } else {
                    console.warn(`[Feedback Server] Submission failed (status ${response.status}). Check server logs.`);
                }
            } catch (error) {
                console.error('[Feedback Server] Network/CORS Error: Could not connect to backend server. Status:', error);
            }
        }


        /**
         * Formats the model's output and embeds source references at the end.
         * @param {string} text The generated text from the model.
         * @param {Array<{uri: string, title: string}>} sources Array of grounding source objects.
         * @returns {string} The formatted HTML output.
         */
        function formatToneAnalysis(text, sources) {
            // 1. Format the structured text
            let formattedText = text.replace(/(\*\*Analysis Result:\*\*)/g, '<strong class="text-indigo-700">Analysis Result:</strong><br/>')
                                    .replace(/(\*\*Score \(1-100\):\*\*)/g, '<br/><strong class="text-indigo-700">Score (1-100):</strong> ')
                                    .replace(/(\*\*Suggested Improvement:\*\*)/g, '<br/><strong class="text-indigo-700">Suggested Improvement:</strong><br/>');

            // 2. Append the references
            let sourcesHtml = '';
            if (sources && sources.length > 0) {
                // Generate full sentences for each source
                const sourceSentences = sources.map((source, index) => 
                    `<p class="mt-2 text-xs text-gray-600">Source ${index + 1}: The information was referenced from the web page titled "<a href="${source.uri}" target="_blank" class="text-indigo-600 hover:text-indigo-800 underline">${source.title}</a>".</p>`
                ).join('');

                sourcesHtml = `
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <strong class="text-sm text-gray-600 block mb-2">References:</strong>
                        ${sourceSentences}
                    </div>
                `;
            } else {
                   sourcesHtml = `
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <p class="text-gray-400 italic text-sm">No external grounding sources were used for this analysis.</p>
                    </div>
                `;
            }

            return formattedText + sourcesHtml;
        }


        /**
         * Calls the Gemini API with exponential backoff for resilience.
         * @param {string} textToAnalyze The text prompt from the user.
         * @param {string} targetTone The desired tone.
         * @returns {Promise<{text: string, sources: Array<{uri: string, title: string}>} | {error: string}>}
         */
        async function callGeminiAPI(textToAnalyze, targetTone) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${API_MODEL}:generateContent?key=${apiKey}`;
            const maxRetries = 5;
            let currentDelay = 1000; // Start with 1 second delay
            
            // 1. Define the System Instruction for the Brand Tone Task
            const systemPrompt = "You are a professional Brand Tone Analyzer. Your task is to evaluate the provided text against a specific target tone. You must output your analysis in the following strict, structured format: **Analysis Result:** [Your detailed assessment of the tone match], **Score (1-100):** [Numeric score representing the tone match], **Suggested Improvement:** [One key suggestion to better match the target tone]. Do not add any conversational remarks, introductions, or closing sentences.";

            // 2. Define the User Query
            const userQuery = `Target Tone: ${targetTone}. Text to analyze: "${textToAnalyze}"`;


            // Prepare the base payload
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };
            

            for (let i = 0; i < maxRetries; i++) {
                try {
                    statusMessage.textContent = `Calling API (Attempt ${i + 1}/${maxRetries})...`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    // Check for rate limit or server errors (429, 500 range)
                    if (!response.ok) {
                        if (response.status === 429 || response.status >= 500) {
                            // Retry logic
                            if (i < maxRetries - 1) {
                                await new Promise(resolve => setTimeout(resolve, currentDelay));
                                currentDelay *= 2; // Exponential backoff
                                continue; 
                            } else {
                                const errorText = await response.text();
                                return { error: `HTTP Error ${response.status} after ${maxRetries} attempts. Details: ${errorText.substring(0, 100)}...` };
                            }
                        } else {
                            // Non-retryable error (e.g., 400 Bad Request)
                            const errorText = await response.text();
                            return { error: `API request failed with HTTP status ${response.status}. Details: ${errorText}` };
                        }
                    }

                    // Successful response
                    const result = await response.json();
                    const candidate = result.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        const text = candidate.content.parts[0].text;
                        let sources = [];

                        // Extract grounding sources
                        const groundingMetadata = candidate.groundingMetadata;
                        if (groundingMetadata && groundingMetadata.groundingAttributions) {
                            sources = groundingMetadata.groundingAttributions
                                .map(attribution => ({
                                    uri: attribution.web?.uri,
                                    title: attribution.web?.title,
                                }))
                                .filter(source => source.uri && source.title);
                        }
                        
                        return { text, sources };

                    } else {
                        // Handle cases where content is missing in a successful HTTP response
                        return { error: "API response was successful but contained no readable text content." };
                    }

                } catch (error) {
                    // Handle network errors (e.g., no internet)
                    if (i < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, currentDelay));
                        currentDelay *= 2;
                        continue;
                    } else {
                        return { error: `Network/Fetch Error after ${maxRetries} attempts: ${error.message}` };
                    }
                }
            }
            return { error: "Exhausted all retries without a successful response." };
        }
    </script>
</body>
</html>